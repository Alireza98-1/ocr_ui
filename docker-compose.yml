# ====================================================================
# Final, Production-Ready docker-compose.yml
# ====================================================================

# --- Top-Level Definitions for Networks and Volumes ---
networks:
  ocr_network:
    driver: bridge
    name: ocr_production_network

# Use named volumes for persistent data, which is a best practice.
volumes:
  redis_data:
  rabbitmq_data:
  app_logs:
  model_weights:
    driver: local
    driver_opts:
      type: 'none'
      o: 'bind'
      device: './weights'
  temp_files:
    driver: local
    driver_opts:
      type: 'none'
      o: 'bind'
      device: './temp_files'

services:
  # -------------------------
  # Infrastructure Services
  # -------------------------
  redis:
    image: redis:7.2-alpine
    container_name: ocr_redis
    volumes:
      - redis_data:/data
    networks:
      - ocr_network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s

  rabbitmq:
    image: rabbitmq:3.13-management-alpine
    container_name: ocr_rabbitmq
    ports:
      - "15672:15672"
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq
    environment:
      - RABBITMQ_DEFAULT_USER=${RABBITMQ_USER:-user}
      - RABBITMQ_DEFAULT_PASS=${RABBITMQ_PASS:-password}
    networks:
      - ocr_network
    healthcheck:
      test: rabbitmq-diagnostics -q ping
      interval: 30s

  # -------------------------
  # Application Services
  # -------------------------
  api:
    build:
      context: .
      dockerfile: Dockerfile
      args:
        REQ_FILE: requirements/api.txt # Build a lightweight API image
    container_name: ocr_api
    user: root # <-- ADDED
    command: gunicorn -w 4 -k uvicorn.workers.UvicornWorker app.main:app --bind 0.0.0.0:8084
    ports:
      - "8000:8084"
    env_file: .env
    volumes:
      - app_logs:/home/appuser/logs # Mount logs volume
    depends_on:
      redis: { condition: service_healthy }
      rabbitmq: { condition: service_healthy }
    networks:
      - ocr_network

  # ===================================
  # Specialized Celery Workers
  # Based on task routing in celery_app.py
  # ===================================

  # 1. Pipeline Worker (Heavy-Duty)
  #    Processes the main OCR tasks. High CPU/Memory, low concurrency.
  worker_pipeline:
    build:
      context: .
      dockerfile: Dockerfile
      args:
        REQ_FILE: requirements/worker.txt # Build the full worker image
    container_name: ocr_worker_pipeline
    user: root # <-- ADDED
    command: celery -A app.worker.celery_app worker -l info -Q ocr_pipeline -c 1
    env_file: .env
    volumes:
      # Use direct bind mounts for local files. ':ro' makes them read-only for safety.
      - ./weights:/home/appuser/weights:ro
      - ./temp_files:/home/appuser/temp_files
      - app_logs:/home/appuser/logs        # For logs
    deploy:
      resources:
        limits: { cpus: '4.0', memory: 14G }
        # reservations:
        #   devices: [{ driver: nvidia, count: 1, capabilities: [gpu] }]
    depends_on:
      redis: { condition: service_healthy }
      rabbitmq: { condition: service_healthy }
    networks:
      - ocr_network

  # 2. Dispatch Worker (Lightweight)
  #    Handles initial task creation. Low CPU/Memory, high concurrency.
  worker_dispatch:
    build:
      context: .
      dockerfile: Dockerfile
      args:
        REQ_FILE: requirements/worker.txt
    container_name: ocr_worker_dispatch
    user: root # <-- ADDED
    command: celery -A app.worker.celery_app worker -l info -Q dispatch -c 4
    env_file: .env
    volumes:
      - temp_files:/home/appuser/temp_files
      - app_logs:/home/appuser/logs
    deploy:
      resources:
        limits: { cpus: '1.0', memory: 2G }
    depends_on: [redis, rabbitmq]
    networks:
      - ocr_network

  # 3. Webhook Worker (I/O Bound)
  #    Only sends network requests. Very low CPU, very high concurrency.
  worker_webhooks:
    build:
      context: .
      dockerfile: Dockerfile
      args:
        REQ_FILE: requirements/worker.txt
    container_name: ocr_worker_webhooks
    user: root # <-- ADDED
    command: celery -A app.worker.celery_app worker -l info -Q webhooks -c 4
    env_file: .env
    volumes:
      - app_logs:/home/appuser/logs
    deploy:
      resources:
        limits: { cpus: '1.0', memory: 2G }
    depends_on: [redis, rabbitmq]
    networks:
      - ocr_network
